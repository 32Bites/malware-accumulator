use std::{
    env,
    error::Error,
    io::{stdout, Stdout, Write},
    iter::Peekable,
    rc::Rc,
};

use futures::{stream, StreamExt};

use crossterm::{
    cursor,
    event::{KeyCode, KeyModifiers},
    execute, queue,
    terminal::{self},
    QueueableCommand,
};
use reqwest::{get, StatusCode};
use scraper::{Html, Selector};
use serde_json::Value;
use tokio::time::{sleep, Duration, Instant};

#[allow(dead_code)]
struct Sample {
    name: String,
    download: String,
    hash: String,
}

impl Sample {
    fn new(name: String, download: String, hash: String) -> Self {
        Self {
            name,
            download,
            hash,
        }
    }
}

async fn scrape_samples() -> Result<Vec<Sample>, Box<dyn Error>> {
    // Fetch a page with a list of malware samples.
    let response = get("https://das-malwerk.herokuapp.com/").await?;

    // Ensure that the get request was successful
    if response.status() != StatusCode::OK {
        return Err("Failed to retrieve a list of malware samples.".into());
    }

    // Get the response body.
    let body_bytes = response.bytes().await?;
    let body: &str = std::str::from_utf8(&body_bytes)?;

    // Parse the body into a html document.
    let html_doc = Html::parse_document(body);

    // Selectors
    let row = Selector::parse("tbody > tr").unwrap();
    let row_cell = Selector::parse("td").unwrap();
    let a = Selector::parse("a").unwrap();

    // Select all table rows
    let rows = html_doc.select(&row);

    // Helper closure
    let failed_retrieving = |input: &str| format!("Failed retrieving malware's {}.", input);

    // The samples we collect
    let mut collected_samples: Vec<Sample> = vec![];

    // Loop through the rows, and gather the needed data from it.
    for row in rows {
        let mut cells = row.select(&row_cell);
        let name = cells.next().ok_or(failed_retrieving("name"))?.inner_html();
        let download = cells
            .next()
            .ok_or(failed_retrieving("download link"))?
            .select(&a)
            .next()
            .ok_or(failed_retrieving("download link"))?
            .value()
            .attr("href")
            .ok_or(failed_retrieving("download link"))?
            .to_string();
        let virus_total = cells
            .next()
            .ok_or(failed_retrieving("virus total link"))?
            .select(&a)
            .next()
            .ok_or(failed_retrieving("virus total link"))?;
        let hash = virus_total.inner_html();

        collected_samples.push(Sample::new(name, download, hash))
    }

    Ok(collected_samples)
}

#[derive(Debug, Clone)]
struct VirusTotalComparison {
    microsoft_defender: (bool, String),
    malwarebytes: (bool, String),
    is_malicious: bool,
    hash: String,
}

async fn virus_total(sample: &Sample) -> Result<VirusTotalComparison, Box<dyn Error>> {
    let api_key = env::var("VTAPI")
        .expect("No environment variable set for the Virus Total API key. Set VTAPI!");
    // Fetch virus total response
    let client = reqwest::Client::new();
    let response = client
        .get(format!(
            "https://www.virustotal.com/api/v3/files/{}",
            sample.hash
        ))
        .header("x-apikey", api_key)
        .send()
        .await?;

    let body_bytes = response.bytes().await?;
    let body: Value = serde_json::from_slice(&body_bytes)?;

    let last_results = &body["data"]["attributes"]["last_analysis_results"];
    // A bit hacky
    let is_malicious = loop {
        let last_stats = &body["data"]["attributes"]["last_analysis_stats"];
        if let Value::Number(malicious_stat) = &last_stats["malicious"] {
            if let Value::Object(results_map) = &last_results {
                // If more than a quarter of the AV vendors classify something as malicious, then it likely is.
                // A quarter is used as some samples may be rather new, so not fully detected by all vendors.
                break malicious_stat.as_u64().unwrap() as usize > (results_map.len() / 4);
            }
        }
        return Err(format!("Failed to get maliciousness value: {}", sample.hash).into());
    };

    let microsoft_defender = loop {
        let vendor = &last_results["Microsoft"];
        if let Value::String(category) = &vendor["category"] {
            if let Value::String(result) = &vendor["result"] {
                break (category == "malicious", result.clone());
            }
        }

        break (false, "".into());
    };

    let malwarebytes = loop {
        let vendor = &last_results["Malwarebytes"];
        if let Value::String(category) = &vendor["category"] {
            if let Value::String(result) = &vendor["result"] {
                break (category == "malicious", result.clone());
            }
        }

        break (false, "".into());
    };

    let comparison = VirusTotalComparison {
        malwarebytes,
        microsoft_defender,
        is_malicious,
        hash: sample.hash.clone(),
    };

    Ok(comparison)
}

fn start_mouse_handler() {
    std::thread::spawn(|| {
        use crossterm::event;
        let mut stdout = stdout();

        loop {
            match event::read() {
                Ok(event) => match event {
                    event::Event::Key(key_event) => match key_event.modifiers {
                        KeyModifiers::CONTROL => {
                            if key_event.code == KeyCode::Char('c') {
                                terminal::disable_raw_mode().unwrap();
                                execute!(stdout, cursor::Show).unwrap();
                                std::process::exit(0)
                            }
                        }
                        _ => {}
                    },
                    _ => {}
                },
                Err(error) => panic!("{:?}", error),
            }
        }
    });
}

async fn handle_comparisons(
    stdout: &mut Stdout,
    sample_chunk: &[Sample],
    all_comparisons: &mut Vec<VirusTotalComparison>,
) -> Result<(), Box<dyn Error>> {
    print!(
        "Gathering VirusTotal data for {} samples: ",
        sample_chunk.len()
    );
    stdout.queue(cursor::SavePosition)?;
    stdout.write_all(b"operation pending")?;
    stdout.queue(cursor::RestorePosition)?;
    stdout.flush()?;
    let mut comparisons: Vec<VirusTotalComparison> = stream::iter(sample_chunk)
        .filter_map(|sample| async move { virus_total(&sample).await.ok() })
        .collect()
        .await;
    all_comparisons.append(&mut comparisons);
    stdout.queue(terminal::Clear(terminal::ClearType::FromCursorDown))?;
    stdout.write_all(b"done.")?;
    stdout.flush()?;
    Ok(())
}

async fn compare_samples<'a, I: Iterator<Item = &'a [Sample]>>(
    mut stdout: &mut Stdout,
    mut malware_samples: Peekable<I>,
) -> Result<Vec<VirusTotalComparison>, Box<dyn Error>> {
    let mut all_comparisons: Vec<VirusTotalComparison> = vec![];
    let minute = Duration::from_secs(60);

    while let Some(sample_chunk) = malware_samples.next() {
        let stdout = &mut stdout;
        let mut all_comparisons = &mut all_comparisons;

        handle_comparisons(stdout, &sample_chunk, &mut all_comparisons).await?;

        queue!(
            stdout,
            cursor::MoveToColumn(0),
            terminal::Clear(terminal::ClearType::FromCursorDown)
        )?;
        stdout.flush()?;

        match malware_samples.peek() {
            Some(next) => {
                let start = Instant::now();
                // handle_comparisons(stdout, &sample_chunk, &mut all_comparisons).await;
                let sleep_duration = minute.saturating_sub(start.elapsed());

                for seconds_remaining in (1..sleep_duration.as_secs()).rev() {
                    stdout.queue(cursor::SavePosition)?;
                    stdout.write_all(
                        format!(
                            "{} seconds remaining before reading next {} samples.",
                            seconds_remaining,
                            next.len()
                        )
                        .as_bytes(),
                    )?;

                    stdout.queue(cursor::RestorePosition)?;
                    stdout.flush()?;
                    sleep(Duration::from_secs(1)).await;

                    stdout.queue(cursor::RestorePosition)?;
                    stdout.queue(terminal::Clear(terminal::ClearType::FromCursorDown))?;
                }
            }
            None => {
                // handle_comparisons(stdout, &sample_chunk, &mut all_comparisons).await;
            }
        }
    }

    Ok(all_comparisons)
}

fn display_comparisons(
    stdout: &mut Stdout,
    comparisons: usize,
    microsoft: usize,
    malwarebytes: usize,
    max: usize,
) -> Result<(), Box<dyn Error>> {
    execute!(
        stdout,
        cursor::Show,
        terminal::Clear(terminal::ClearType::FromCursorDown)
    )?;
    write!(
        stdout,
        "Successful Comparisons: ({}/{}) {:.2}%\r\n",
        comparisons,
        max,
        (comparisons as f64 / max as f64) * 100.0
    )?;
    write!(
        stdout,
        "Microsoft Success Rate: ({}/{}) {:.2}%\r\n",
        microsoft,
        max,
        (microsoft as f64 / max as f64) * 100.0
    )?;
    write!(
        stdout,
        "Malwarebytes Success Rate: ({}/{}) {:.2}%\r\n",
        malwarebytes,
        max,
        (malwarebytes as f64 / max as f64) * 100.0
    )?;

    stdout.flush()?;

    Ok(())
}

fn save_comparisons<I: Iterator<Item = Rc<VirusTotalComparison>>>(
    stdout: &mut Stdout,
    comparisons: I,
) -> Result<(), Box<dyn Error>> {
    let mut microsoft = csv::Writer::from_path("microsoft.csv")?;
    let mut malwarebytes = csv::Writer::from_path("malwarebytes.csv")?;

    let header = ["hash", "is_malicious", "did_detect", "name"];
    microsoft.write_record(&header)?;
    malwarebytes.write_record(&header)?;

    let bool_str = |b: bool| match b {
        true => "yes",
        false => "no",
    };

    for comparison in comparisons {
        let hash = comparison.hash.clone();
        let is_malicious = bool_str(comparison.is_malicious);
        let microsoft_detected = bool_str(comparison.microsoft_defender.0);
        let microsoft_name = comparison.microsoft_defender.1.clone();
        let malwarebytes_detected = bool_str(comparison.malwarebytes.0);
        let malwarebytes_name = comparison.malwarebytes.1.clone();

        microsoft.write_record(&[&hash, is_malicious, microsoft_detected, &microsoft_name])?;
        malwarebytes.write_record(&[
            &hash,
            is_malicious,
            malwarebytes_detected,
            &malwarebytes_name,
        ])?;
    }

    microsoft.flush()?;
    malwarebytes.flush()?;
    write!(stdout, "Saved microsoft.csv and malwarebytes.csv\r\n")?;
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Initialize command line.
    terminal::enable_raw_mode()?;
    start_mouse_handler();

    let mut stdout = stdout();
    execute!(stdout, cursor::Hide)?;
    stdout.write_all(b"Gathering sample data, please wait.")?;
    stdout.queue(cursor::MoveToColumn(0))?;
    stdout.flush()?;

    // Scrape malware samples
    let malware_samples = scrape_samples().await?;

    // Group malware samples
    let len = malware_samples.len();
    let max = match env::args().nth(1) {
        Some(max) => max.parse::<usize>()?,
        None => 20,
    };
    let max = len.min(max);
    let malware_samples = malware_samples[..max].chunks(4).peekable();

    // Inform user of found samples.
    stdout.queue(terminal::Clear(terminal::ClearType::FromCursorDown))?;
    if len > max {
        stdout.write_all(
            format!("Found {} samples, but will only use {}.\r\n", len, max).as_bytes(),
        )?;
    } else {
        stdout.write_all(format!("Found {} samples to use.\r\n", len).as_bytes())?;
    }
    stdout.flush()?;

    // Start gathering Virus Total data for comparison.
    let comparisons = compare_samples(&mut stdout, malware_samples).await?;

    // Gather successful comparisons for each antimalware and count them.
    let comparisons = comparisons
        .into_iter()
        .map(|comparison| Rc::new(comparison));

    let microsoft_count = comparisons
        .clone()
        .filter(|comparison| comparison.is_malicious && comparison.microsoft_defender.0)
        .count();
    let malwarebytes_count = comparisons
        .clone()
        .filter(|comparison| comparison.is_malicious && comparison.malwarebytes.0)
        .count();
    let comparison_count = comparisons.clone().count();

    // Display results
    display_comparisons(
        &mut stdout,
        comparison_count,
        microsoft_count,
        malwarebytes_count,
        max,
    )?;

    // Save results
    save_comparisons(&mut stdout, comparisons)?;

    // Fix command line
    terminal::disable_raw_mode()?;
    Ok(())
}
